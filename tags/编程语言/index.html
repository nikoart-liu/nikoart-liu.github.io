<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>编程语言 | Spicy Bits</title><meta name=keywords content><meta name=description content="Spicy Bits"><meta name=author content="nikoart"><link rel=canonical href=https://nikoart-liu.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/><link crossorigin=anonymous href=/assets/css/stylesheet.da3211e5ef867bf2b75fd5a6515cfed7195c011e8ab735694e203810a827097b.css integrity="sha256-2jIR5e+Ge/K3X9WmUVz+1xlcAR6KtzVpTiA4EKgnCXs=" rel="preload stylesheet" as=style><link rel=icon href=https://nikoart-liu.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nikoart-liu.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nikoart-liu.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://nikoart-liu.github.io/apple-touch-icon.png><link rel=mask-icon href=https://nikoart-liu.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://nikoart-liu.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml title=rss><link rel=alternate hreflang=en href=https://nikoart-liu.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://nikoart-liu.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><meta property="og:site_name" content="Spicy Bits"><meta property="og:title" content="编程语言"><meta property="og:description" content="Spicy Bits"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="编程语言"><meta name=twitter:description content="Spicy Bits"></head><body class=list id=top><header class=header><nav class=nav><div class=logo><a href=https://nikoart-liu.github.io/ accesskey=h title="Spicy Bits (Alt + H)">Spicy Bits</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://nikoart-liu.github.io/archives/ title=归档><span>归档</span></a></li><li><a href=https://nikoart-liu.github.io/categories/ title=分类><span>分类</span></a></li><li><a href=https://nikoart-liu.github.io/tags/ title=标签><span>标签</span></a></li><li><a href=https://nikoart-liu.github.io/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://nikoart-liu.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://nikoart-liu.github.io/tags/>Tags</a></div><h1>编程语言</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rust - 迭代器与闭包</h2></header><div class=entry-content><p>Rust - 迭代器与闭包 知识概览 核心主题：Iterator trait、惰性求值、常用适配器 (map, filter, collect)、闭包捕获与 Fn/FnMut/FnOnce。 重要性：⭐⭐⭐⭐⭐ 在数据处理、流式计算、函数式编程中必备。 前置知识：所有权、借用、match、Result（错误处理）。 核心概念 1. Iterator trait & 惰性求值 trait Iterator { type Item; fn next(&amp;mut self) -> Option&lt;Self::Item>; } 惰性：仅在调用 next()（或消费方法如 collect, fold）时产生元素。 优势：省内存、可提前终止（如 find、any），提升性能。 2. 迭代器常用方法 方法 说明 示例 into_iter() 消费所有权，返回 T vec.into_iter() iter() 只读引用 &amp;T vec.iter() filter 过滤满足条件的元素 .filter(|x| x% 2 == 0) map 转换元素 .map(|x| x * x) collect 收集到容器 .collect::&lt;Vec&lt;_>>() fold 累积状态 .fold(0,|acc, x| acc + x) 检查点答案 iter() 返回 &amp;T 迭代器，into_iter() 返回拥有所有权的 T。 collect() 在 filter+map 链中只会在最终调用时遍历一次。 3. 闭包捕获方式 捕获方式 关键字 适用场景 按引用 无 filter(|x| x.starts_with(prefix))（prefix 为 &amp;str） 按可变引用 &amp;mut for_each(|x| cnt += 1) 按值 (move) move 需要所有权，如 let s = String::from("hi"); let c = move |x| x; Fn：只读捕获（filter, map） FnMut：可变捕获（for_each 改变外部变量） FnOnce：移动捕获（一次性消费） 4. 链式适配器与实际案例 词频统计（示例） use std::collections::HashMap; use std::fs; fn main() { let text = fs::read_to_string("poem.txt").expect("read failed"); // 统计所有单词频率 let freq: HashMap&lt;String, usize> = text .split_whitespace() .fold(HashMap::new(), |mut map, word| { *map.entry(word.to_string()).or_insert(0) += 1; map }) // 过滤出现次数 >= 2 的词 .into_iter() .filter(|(_, count)| *count >= 2) .collect(); println!("{:?}", freq); } 关键在 into_iter() 后再 filter，避免引用与所有权冲突。 常见陷阱 问题 原因 解决方案 collect() 后的 HashMap 再 iter() 导致引用错误 需要拥有所有权进行过滤 使用 into_iter() 或克隆键值 在 filter 中捕获 String 而不 move 默认按引用捕获导致借用冲突 加 move 或使用 &amp;str 预先借用 误把 iter() 当作消费所有权 iter() 只借用，后续使用会报错 根据需求选择 into_iter() 或 iter() 关键要点 惰性：只有在消费时才遍历。 所有权 vs 引用：into_iter() 消费，iter() 借用。 闭包捕获：move 取得所有权，Fn/FnMut/FnOnce 对应捕获方式。 链式：filter -> map -> collect 形成数据管道，保持简洁。 错误处理：Result 与 expect 用于文件读取等 IO 操作。</p></div><footer class=entry-footer><span title='2026-01-29 14:51:43 +0800 +0800'>January 29, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>229 words</span>&nbsp;·&nbsp;<span>nikoart</span></footer><a class=entry-link aria-label="post link to Rust - 迭代器与闭包" href=https://nikoart-liu.github.io/posts/rust%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E9%97%AD%E5%8C%85/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rust - IO</h2></header><div class=entry-content><p>Rust - I/O 知识概览 核心主题：构建命令行搜索工具（minigrep） 重要性：⭐⭐⭐⭐⭐ 综合应用前几章知识 前置知识：环境安装、所有权、Trait、错误处理 核心概念 命令行参数解析 use std::env; fn main() { let args: Vec&lt;String> = env::args().collect(); // args[0] = 程序名 // args[1] = 第一个参数 // args[2] = 第二个参数 println!("搜索词: {}", args[1]); println!("文件: {}", args[2]); } 文件读取 use std::fs; let contents = fs::read_to_string(filename) .expect("无法读取文件"); // contents 是 String，包含整个文件内容 配置模式（Config Pattern） struct Config { query: String, filename: String, case_sensitive: bool, } impl Config { fn new(args: &[String]) -> Result&lt;Config, &'static str> { if args.len() &lt; 3 { return Err("参数不足"); } let query = args[1].clone(); let filename = args[2].clone(); let case_sensitive = !args.iter().any(|arg| arg == "-i"); Ok(Config { query, filename, case_sensitive }) } } 错误处理 场景 方式 示例 致命错误 expect fs::read_to_string(...).expect(...) 可恢复错误 Result + match Config::new(...)? 用户提示 eprintln! eprintln!("用法: ...") 项目结构 minigrep/ ├── src/ │ └── main.rs # 主程序 ├── Cargo.toml └── poem.txt # 测试文件 完整代码 // src/main.rs use std::env; use std::fs; struct Config { query: String, filename: String, case_sensitive: bool, } impl Config { fn new(args: &[String]) -> Result&lt;Config, &'static str> { if args.len() &lt; 3 { return Err("参数不足"); } let query = args[1].clone(); let filename = args[2].clone(); let case_sensitive = !args.iter().any(|arg| arg == "-i"); Ok(Config { query, filename, case_sensitive }) } } fn main() { let args: Vec&lt;String> = env::args().collect(); let config = match Config::new(&amp;args) { Ok(config) => config, Err(e) => panic!("{e}"), }; let contents = fs::read_to_string(&amp;config.filename) .expect("无法读取文件"); let results = search(&amp;config, &amp;contents); for line in results { println!("{line}"); } } fn search&lt;'a>(config: &'a Config, contents: &'a str) -> Vec&lt;&'a str> { let query = config.query.to_lowercase(); let mut results = Vec::new(); for line in contents.lines() { if config.case_sensitive { if line.contains(&amp;config.query) { results.push(line); } } else { if line.to_lowercase().contains(&amp;query) { results.push(line); } } } results } 运行命令 # 基本搜索 cargo run -- hello poem.txt # 大小写不敏感搜索 cargo run -- -i hello poem.txt 常见陷阱 问题 原因 解决方案 参数越界 忘记检查 args.len() 加长度检查 大小写搜索低效 query.to_lowercase() 重复计算 提取到循环外 所有权转移 String 传入函数 使用引用 &amp;str 关键要点 env::args() 返回 Iterator fs::read_to_string() 读取整个文件 Config 模式解耦配置与业务逻辑 大小写不敏感：两边都转小写再比较 用 Result 处理用户输入错误更优雅</p></div><footer class=entry-footer><span title='2026-01-29 14:50:22 +0800 +0800'>January 29, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>324 words</span>&nbsp;·&nbsp;<span>nikoart</span></footer><a class=entry-link aria-label="post link to Rust - IO" href=https://nikoart-liu.github.io/posts/rustio/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rust - 自动化测试</h2></header><div class=entry-content><p>Rust - 自动化测试 知识概览 核心主题：Rust 内置测试框架、单元测试、集成测试 重要性：⭐⭐⭐⭐ 掌握测试是工程化开发的基础 前置知识：泛型与 Trait（第10章）、所有权（第4章） 核心概念 测试框架架构 Rust 内置测试框架，无需外部依赖，通过 #[test] 属性标记测试函数。
#[cfg(test)] // 仅在测试时编译 mod tests { use super::*; // 访问被测试模块 #[test] fn it_works() { assert_eq!(2 + 2, 4); assert!(true); } #[test] #[should_panic(expected = "错误信息")] fn it_panics() { panic!("错误信息"); } } 断言宏 宏 用途 示例 assert!(cond) 条件为真 assert!(x > 0) assert_eq!(a, b) 两值相等 assert_eq!(result, 5) assert_ne!(a, b) 两值不等 assert_ne!(result, 0) 测试组织方式 单元测试：同文件 mod tests 内 集成测试：tests/ 目录下的独立文件 文档测试：doc comment /// 中的代码示例 常用派生 trait #[derive(Debug, Clone, PartialEq)] pub struct Rectangle { pub width: u32, pub height: u32, } trait 作用 Debug 支持 {:?} 打印 Clone 支持 .clone() 克隆 PartialEq 支持 = 比较 实践项目 Rectangle 结构体测试 #[derive(Debug)] pub struct Rectangle { pub width: u32, pub height: u32, } impl Rectangle { pub fn can_hold(&amp;self, other: &amp;Rectangle) -> bool { self.width >= other.width && self.height >= other.height } } #[cfg(test)] mod tests { use super::*; #[test] fn larger_can_hold_smaller() { let larger = Rectangle { width: 8, height: 7 }; let smaller = Rectangle { width: 5, height: 1 }; assert!(larger.can_hold(&amp;smaller)); } #[test] fn smaller_cannot_hold_larger() { let larger = Rectangle { width: 4, height: 7 }; let smaller = Rectangle { width: 5, height: 1 }; assert!(!larger.can_hold(&amp;smaller)); } } 常见陷阱 问题 原因 解决方案 字段不可访问 字段默认私有 pub struct 或公开字段 所有权转移 参数为 Rectangle 而非 &amp;Rectangle 使用借用 &amp;Rectangle 调试打印失败 未派生 Debug 添加 #[derive(Debug)] 运行测试 cargo test # 运行所有测试 cargo test test_name # 运行指定测试 关键要点 #[cfg(test)] 仅在测试时编译 #[test] 标记测试函数 #[should_panic] 预期 panic 用 &amp;Rectangle 借用避免所有权转移 #[derive(Debug)] 支持调试打印</p></div><footer class=entry-footer><span title='2026-01-29 14:49:23 +0800 +0800'>January 29, 2026</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>244 words</span>&nbsp;·&nbsp;<span>nikoart</span></footer><a class=entry-link aria-label="post link to Rust - 自动化测试" href=https://nikoart-liu.github.io/posts/rust%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Rust - 泛型、Trait 和生命周期</h2></header><div class=entry-content><p>Rust - 泛型、Trait 和生命周期 知识概览 本章核心主题：通过抽象机制消除代码重复，实现灵活且安全的代码 重要程度：⭐⭐⭐（核心概念，后续章节的基础） 预计学习时间：2-3小时 前置知识要求： 基本语法（变量、函数、结构体、枚举） 所有权和借用 错误处理的基础（Option、Result） 核心概念 泛型类型（Generics） 定义：允许代码处理多种类型而非具体类型的抽象机制
官方文档：
url: https://doc.rust-lang.org/book/ch10-01-syntax.html title: "Generic Data Types - The Rust Programming Language" host: doc.rust-lang.org favicon: favicon-de23e50b.svg 语法：
// 函数泛型 fn largest&lt;T: PartialOrd>(list: &[T]) -> &amp;T { let mut largest = &amp;list[0]; for item in list { if item > largest { largest = item; } } largest } // 结构体泛型（单泛型） struct Point&lt;T> { x: T, y: T, } // 结构体泛型（多泛型） struct Point&lt;T, U> { x: T, y: U, } // impl 块 impl&lt;T> Point&lt;T> { fn x(&amp;self) -> &amp;T { &amp;self.x } } // 为特定类型实现方法 impl Point&lt;f32> { fn distance_from_origin(&amp;self) -> f32 { (self.x.powi(2) + self.y.powi(2)).sqrt() } } 性能：通过单态化在编译时生成具体类型代码，零运行时开销
...</p></div><footer class=entry-footer><span title='2026-01-29 14:46:33 +0800 +0800'>January 29, 2026</span>&nbsp;·&nbsp;<span>4 min</span>&nbsp;·&nbsp;<span>790 words</span>&nbsp;·&nbsp;<span>nikoart</span></footer><a class=entry-link aria-label="post link to Rust - 泛型、Trait 和生命周期" href=https://nikoart-liu.github.io/posts/rust%E6%B3%9B%E5%9E%8Btrait%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/></a></article></main><footer class=footer><span>&copy; 2026 <a href=https://nikoart-liu.github.io/>Spicy Bits</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>